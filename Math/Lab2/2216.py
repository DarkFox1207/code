import numpy as np

def zeidel_ex(a, b, n, w, epsilon=0.01):
    x = np.zeros(n)  # Начальное приближение
    step = 0  # Счетчик итераций

    while True:
        step += 1
        x_new = x.copy()  # Копируем текущее решение для обновления

        for i in range(n):
            # Считаем сумму для первой и второй части строки
            sum1 = np.dot(a[i, :i], x_new[:i])  # Сумма по первой части строки
            sum2 = np.dot(a[i, i+1:], x[i+1:])  # Сумма по второй части строки

            # Обновляем значение для x_i
            x_new[i] = (1 - w) * x[i] + w * (b[i] - sum1 - sum2) / a[i, i]

        # Проверяем сходимость: если изменение вектора меньше порога, выходим
        if np.linalg.norm(x_new - x, ord=np.inf) < epsilon:
            break
        
        x = x_new  # Обновляем значение решения

    return x_new, step

# Система уравнений
a = np.array([
    [19.9000, 0.0849, 0.1020, 0.1191],  # Коэффициенты для первого уравнения
    [0.0626, 19.0000, 0.0969, 0.1140],  # Коэффициенты для второго уравнения
    [0.0576, 0.7470, 18.1000, 0.1090],  # Коэффициенты для третьего уравнения
    [0.0525, 0.0696, 0.0867, 17.2000]   # Коэффициенты для четвертого уравнения
])

b = np.array([36.5001, 38.5997, 40.3345, 41.7045])  # Правая часть системы

n = 4  # Количество переменных в системе
w = 1.0  # Параметр омега (для стандартного метода Зейделя w=1.0)

# Вызываем метод
solution, iterations = zeidel_ex(a, b, n, w)

print("Решение системы:", solution)
print("Количество итераций:", iterations)
